        -:    0:Source:src/string_utils.c
        -:    0:Graph:profiling/gc/string_utils.gcno
        -:    0:Data:profiling/gc/string_utils.gcda
        -:    0:Runs:1
        -:    1:#include <string.h>
        -:    2:#include "string_utils.h"
        -:    3:#include "definitions.h"
        -:    4:#include "util.h"
        -:    5:#include <stdio.h>
        -:    6:#include <ctype.h>
        -:    7:#include "process_file.h"
        -:    8:#include "funcpointers.h"
        -:    9:
        -:   10:/*
        -:   11: * Turns the line into sz number of tokens, depending on the delimeters.
        -:   12: */
    #####:   13:char** tokenize(char* line, char* delimeters, size_t* sz)
        -:   14:{
    #####:   15:   char** tokens;
    #####:   16:   char* token;
        -:   17:   
    #####:   18:   tokens = xcalloc(MAX_LINE_LENGTH / MAX_WORD_LENGTH, \
        -:   19:           sizeof(char*));
    #####:   20:   *sz = 0;
    #####:   21:   token = strtok(line, delimeters);
    #####:   22:   do {
    #####:   23:        tokens[*sz] = xcalloc(strlen(token) + 1, sizeof(char));
    #####:   24:        strcpy(tokens[*sz], token);
    #####:   25:        ++(*sz);
    #####:   26:   } while((token = strtok(NULL, " ")) != NULL); 
    #####:   27:   return tokens;
        -:   28:}
        -:   29:
        -:   30:/*
        -:   31: * Search the string str for the token and replaces it with the replacement.
        -:   32: * Returns the a heap allocated string which has been modified. 
        -:   33: */
       89:   34:char* search_and_replace(char* str, const char* token, char* replacement) 
        -:   35:{
       89:   36:    char* replaced;
       89:   37:    replaced = xcalloc(strlen(replacement) + MAX_LINE_LENGTH, sizeof(char));
       89:   38:    char* f; 
       89:   39:    if ((f = strstr(str, token)) != NULL) {
        -:   40:        /* Copy the first part of the string */
       89:   41:        strncpy(replaced, str, f - str); 
       89:   42:        size_t head_size = f - str;
        -:   43:        /* Insert the replacement */
       89:   44:        strcpy(replaced + strlen(replaced), replacement);
        -:   45:        /* Insert the tail of the string */
       89:   46:        strcpy(replaced + strlen(replaced), str + head_size + strlen(token));
        -:   47:    }
       89:   48:    return replaced;
        -:   49:
        -:   50:}
        -:   51:
        -:   52:/*
        -:   53: * Replaces all occurences of tokens in str, with their replacements.
        -:   54: * cnt is the number of tokens to in **tokens.
        -:   55: */
       28:   56:char* search_and_replace_all(char* str, char** tokens, char** replacements, size_t cnt) 
        -:   57:{
       28:   58:    char buffer[MAX_LINE_LENGTH];
       28:   59:    strcpy(buffer, str);
       28:   60:    size_t i;
       28:   61:    char* intermediate;
       93:   62:    for (i = 0; i < cnt; ++i){
       65:   63:        while(contains(buffer, tokens[i])) {
       54:   64:            intermediate = search_and_replace(buffer, tokens[i], replacements[i]);
       54:   65:            if (intermediate != NULL) {
       54:   66:                strcpy(buffer, intermediate);
       54:   67:                free(intermediate);
        -:   68:            }
        -:   69:        }
        -:   70:    }
       28:   71:    char* final = xcalloc(strlen(buffer) + 1, sizeof(char));
       28:   72:    strcpy(final, buffer);
       28:   73:    return final;
        -:   74:}
        -:   75:
        -:   76:/*
        -:   77: * Checks if a string, str, contains the token token.
        -:   78: * RETURN:
        -:   79: *  1 if str contains token.
        -:   80: *  0 Otherwise.
        -:   81: */
     1548:   82:int contains(char* str, char* token) 
        -:   83:{
     1548:   84:    if (token == NULL || str == NULL)
        -:   85:        return 0;
     1548:   86:    return strstr(str, token) != NULL;
        -:   87:}
        -:   88:
        -:   89:/*
        -:   90: * Trims the str of all white space.
        -:   91: */
       10:   92:void trim_whitespace(char* str)
        -:   93:{
       10:   94:   char* tokens[] = {" ", "\t"};
       10:   95:   char* replacements[] = {"", ""};
       10:   96:   char* trimmed = search_and_replace_all(str, tokens, replacements, 2);
       10:   97:   strcpy(str, trimmed);
       10:   98:   free(trimmed);
       10:   99:}
        -:  100:
        -:  101:/*
        -:  102: * Trims leading white space from a string.
        -:  103: */
       27:  104:void trim_leading_whitespace(char* str)
        -:  105:{
       27:  106:    size_t i;
       27:  107:    size_t len;
       27:  108:    char* cpy = xcalloc(strlen(str) + 1, sizeof(char));
       27:  109:    char* orig_pos = cpy;
       27:  110:    strcpy(cpy, str);
       27:  111:    len = strlen(cpy);
      521:  112:    for (i = 0; i < len; ++i) {
      521:  113:        if (cpy[i] != ' ' && cpy[i] != '\t')
        -:  114:            break;
        -:  115:        else {
      494:  116:            cpy += 1;
      494:  117:            i--;
        -:  118:        }
        -:  119:    }
       27:  120:    strcpy(str, cpy);
       27:  121:    free(orig_pos);
       27:  122:}
        -:  123:
        1:  124:char* expand_file(FILE* file)
        -:  125:{
        1:  126:    size_t length;
        1:  127:    char* buffer;
        -:  128:    /* Find the number of bytes in the file */
        1:  129:    fseek(file, 0L, SEEK_END);
        1:  130:    length = ftell(file);
        -:  131:
        -:  132:    /* Rewind the file to beginning */
        1:  133:    rewind(file);
        -:  134:
        -:  135:    /* Allocate appropriate amount */
        1:  136:    buffer = xcalloc(length + 1, sizeof(char));
        -:  137:
        -:  138:    /* Read file into buffer */
        1:  139:    fread(buffer, sizeof(char), length, file);
        -:  140:
        1:  141:    return buffer;
        -:  142:
        -:  143:}
