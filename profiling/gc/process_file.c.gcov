        -:    0:Source:src/process_file.c
        -:    0:Graph:profiling/gc/process_file.gcno
        -:    0:Data:profiling/gc/process_file.gcda
        -:    0:Runs:1
        -:    1:#include "process_file.h"
        -:    2:#include <stdio.h>
        -:    3:#include <stdlib.h>
        -:    4:#include "util.h"
        -:    5:#include <string.h>
        -:    6:#include "hashmap.h"
        -:    7:#include "definitions.h"
        -:    8:#include "string_utils.h"
        -:    9:#include "file_inclusion.h"
        -:   10:#include "globals.h"
        -:   11:#include "funcpointers.h"
        -:   12:
        -:   13:/*
        -:   14: * Read all macro defintions and put them in the map.
        -:   15: */
        -:   16:long long line_number = 0;
        1:   17:void process(FILE* input, FILE* output)
        -:   18:{
        1:   19:    hash_table* map = new_hash_table(cmp, hash, delete_key, delete_val);
       68:   20:    char line[MAX_LINE_LENGTH];
      135:   21:    while(1) {
        -:   22:        /* Assume no line longer than MAX_LINE_LENGTH chars */
       68:   23:        char* r = fgets(line,MAX_LINE_LENGTH - 1, input);
       68:   24:        if (r == NULL)
        -:   25:            break;
       67:   26:        else if (comment_cnt == 0 && strcmp(line, NEWLINE_CHAR) == 0) /* Empty line */
        6:   27:                fputs("\n", output);
        -:   28:            /* normal word write to output */
       61:   29:        else if (comment_cnt == 0 && line[0] != RESERVED_MACRO_CHAR )
       35:   30:                write_line(map, line, output);
       26:   31:        else if(line[0] == RESERVED_MACRO_CHAR) /* Add since it is a macro line. */
       24:   32:                add_macro(line, map);
       67:   33:        ++line_number;
        -:   34:    }
        1:   35:    free(macro_keys);
        1:   36:    delete_hash_table(map);
        1:   37:} 
        -:   38:
        -:   39:/*
        -:   40: * Init. global vars.
        -:   41: */
        -:   42:size_t cnt = 0;
        -:   43:char** macro_keys = NULL;
        -:   44:
        -:   45:/*
        -:   46: * Checks if there are any new keys. 
        -:   47: * If there are new keys sort and refresh the key variable.
        -:   48: */
       69:   49:void m_keys(const hash_table* macros) {
       69:   50:    if (has_new_keys) {
        6:   51:        free(macro_keys);
        6:   52:        macro_keys = (char**) keys(macros, &cnt);
        6:   53:        qsort(macro_keys, cnt, sizeof(char*), string_cmp);
        6:   54:        has_new_keys = 0;
        -:   55:    } 
       69:   56:}
        -:   57:
        -:   58:/* 
        -:   59: * Write line to output after checking for any macros present in it.
        -:   60: */
       35:   61:void write_line(hash_table* macros, char* line, FILE* output)
        -:   62:{
        -:   63:    /* Check if line contains any of the macros in the table,
        -:   64:     * if so expand them if possible 
        -:   65:     */
       35:   66:    macro_t* m;
       35:   67:    size_t i;
        -:   68:
        -:   69:    /* Check if new keys are available and sorts them if so */
       35:   70:    m_keys(macros);
        -:   71:
      775:   72:    for (i = 0; i < cnt; ++i) {
      718:   73:        while (contains(line, macro_keys[i])) {
       13:   74:            m = lookup(macros, macro_keys[i]);
       13:   75:            if (m != NULL) {
       13:   76:                expand_macro(macro_keys[i], line, m, macros);
        -:   77:            }
        -:   78:        } 
        -:   79:    }
       35:   80:    fputs(line, output);
       35:   81:}
        -:   82:
        -:   83:/* 
        -:   84: * Recursively check the line if it still contains any macros.
        -:   85: */
       34:   86:void recursive_check_line(const hash_table* macros, char* line)
        -:   87:{
        -:   88:    /* Check if line contains any of the macros in the table,
        -:   89:     * if so expand them if possible 
        -:   90:     */
       34:   91:    macro_t* m;
       34:   92:    size_t i;
        -:   93:
        -:   94:    /* Check if new keys are available and sorts them if so */
       34:   95:    m_keys(macros);
        -:   96:
      757:   97:    for (i = 0; i < cnt; ++i) {
      711:   98:        while (contains(line, (char*) macro_keys[i])) {
       22:   99:            m = lookup(macros, macro_keys[i]);
       22:  100:            if (m != NULL) {
       22:  101:                expand_macro(macro_keys[i], line, m, macros);
        -:  102:            }
        -:  103:        } 
        -:  104:    }
       34:  105:}
        -:  106:
       35:  107:void expand_macro(char* key, char* line, const macro_t* macro, const hash_table* macros)
        -:  108:{
       35:  109:    switch(macro->type) {
       16:  110:        case DEF:
        -:  111:            {
       16:  112:                def_m* m = macro->macro;
       16:  113:                char* tmp = search_and_replace(line, key, m->expansion);
       16:  114:                recursive_check_line(macros, tmp);
       16:  115:                strcpy(line, tmp);
       16:  116:                free(tmp);
        -:  117:            }
       16:  118:            break;
       18:  119:        case FUN:
        -:  120:            {
       18:  121:                char* expanded = expand_function(key, line, macro);
       18:  122:                recursive_check_line(macros, expanded);
       18:  123:                strcpy(line, expanded);  
       18:  124:                free(expanded);
        -:  125:            }
       18:  126:            break;
        1:  127:        case FLE:
        -:  128:            {
        -:  129:                /* Replace the key in the line */
        1:  130:                file_m* m = macro->macro;
        1:  131:                char* expanded_file = expand_file(m->file);
        1:  132:                char* replaced = search_and_replace(line, key, expanded_file);
        1:  133:                strcpy(line, replaced);
        1:  134:                free(expanded_file);
        1:  135:                free(replaced);
        -:  136:            }
        -:  137:        default:
        -:  138:            break;
        -:  139:    }
       35:  140:}
        -:  141:
        -:  142:/*
        -:  143: * Expands the function.
        -:  144: */
       18:  145:char* expand_function(const char* key, char* line, const macro_t* macro) 
        -:  146:{
       18:  147:    func_m* m = macro->macro;
       18:  148:    char** line_args = xcalloc(m->argc, sizeof(char*));
       18:  149:    char* key_il;
       18:  150:    char line_cpy[MAX_LINE_LENGTH]; /* TODO correct size */
       18:  151:    size_t pos_of_parentheses;
        -:  152:
        -:  153:    /* Find instance of key in line */
       18:  154:    strcpy(line_cpy, line);
       18:  155:    key_il = strstr(line_cpy, key);
        -:  156:
        -:  157:    /* Find the pos of parentheses*/
       18:  158:    pos_of_parentheses = key_il - line_cpy + strlen(key);
       18:  159:    char* line_p = line_cpy + pos_of_parentheses;
        -:  160:
       18:  161:    size_t l_par, r_par, last_delim, i, k;
       18:  162:    l_par = r_par = last_delim = i = k = 0;
       18:  163:    if (line_p[i] != '(')
    #####:  164:        formatted_uerror("Missing '(' in function call.\n", NULL);
        -:  165:
        -:  166:    last_delim = i++; 
        -:  167:    l_par++;
        -:  168:
        -:  169:    /* Read the args inside the parentheses */
      560:  170:    for (; line_p[i] != '\n' && l_par > r_par; ++i) {
      542:  171:        if (line_p[i] == '(')
        9:  172:            ++l_par;
      533:  173:        else if (line_p[i] == ')') {
       27:  174:            ++r_par;
       27:  175:            if (l_par == r_par)
       18:  176:                goto COPY;
        -:  177:        }
      506:  178:        else if (line_p[i] == ',')
       40:  179:            if (l_par == r_par + 1) {
       27:  180:COPY:           
       45:  181:                if (k >= m->argc)
    #####:  182:                    formatted_uerror("To many arguments in function!\n", NULL);
        -:  183:
       45:  184:                line_args[k] = xcalloc(i - last_delim, sizeof(char)); 
       45:  185:                strncpy(line_args[k++], line_p + last_delim  + 1, i - last_delim - 1);
       45:  186:                last_delim = i;
        -:  187:            }
        -:  188:    }
       18:  189:    if (k < m->argc)
    #####:  190:        formatted_uerror("To few arguments in function!\n", NULL);
        -:  191:    
        -:  192:
        -:  193:    /* Replaced the arguments provided with to the expansion */
       18:  194:    char* expansion = search_and_replace_all(m->expansion, m->argv, \
        -:  195:            line_args, m->argc);
        -:  196:
       18:  197:    char* concat;
       18:  198:    concat = xcalloc(strlen(key) + m->argc * MAX_WORD_LENGTH + 1, sizeof(char));
       18:  199:    char key_cpy[strlen(key) + 1];
       18:  200:    strcpy(key_cpy, key);
       18:  201:    strcat(concat, key_cpy);
       18:  202:    strcat(concat, "(");
       63:  203:    for (i = 0; i < m->argc; ++i) {
       45:  204:        strcat(concat, line_args[i]);
       45:  205:        if( i + 1 != m->argc)
       27:  206:            strcat(concat, ",");
        -:  207:    }
       18:  208:    strcat(concat, ")");
        -:  209:    /* Replace the key and the arg list in the string with the expansion */
       18:  210:    char* final = search_and_replace(line, concat, expansion);
       81:  211:    for(i = 0; i < m->argc; ++i)
       45:  212:        free(line_args[i]);
       18:  213:    free(line_args);
       18:  214:    free(concat);
       18:  215:    free(expansion);
       18:  216:    return final;
        -:  217:}
        -:  218:
        -:  219:/*
        -:  220: * Init global vars.
        -:  221: */
        -:  222:unsigned has_new_keys = 0;
        -:  223:size_t comment_cnt    = 0;
        -:  224:
        -:  225:/*
        -:  226: * Adds macros to the hash table
        -:  227: */
       29:  228:void add_macro(char* line, hash_table* t)
       29:  229:{
       29:  230:    char* macro_type;
       29:  231:    char* key;
       29:  232:    macro_t* m;
       29:  233:    char line_cpy[strlen(line) + 1]; /* Needed for error handling */
        -:  234:
       29:  235:    m = xmalloc(sizeof(macro_t));
       29:  236:    key = xcalloc(MAX_WORD_LENGTH + 1, sizeof(char));
       29:  237:    strcpy(line_cpy, line);
       29:  238:    macro_type = strtok(line, " \t\n"); 
       29:  239:    if (macro_type[0] != RESERVED_MACRO_CHAR){ /* TODO This is a stupid fix */
    #####:  240:        free(m);
    #####:  241:        free(key);
    #####:  242:        return;
        -:  243:    } 
       39:  244:    if (comment_cnt == 0 && strcmp(macro_type, MACRO_DEF) == 0) {
        -:  245:        /* Add as simple replacement macro */
       10:  246:        def_m* d_m = xmalloc(sizeof(def_m));
       10:  247:        strcpy(key, strtok(NULL, " \t"));
       10:  248:        if (lookup(t, key))
    #####:  249:            formatted_uerror("Multiple definitions of key: %s\n", key);
        -:  250:
       10:  251:        char* expansion = strtok(NULL, NEWLINE_CHAR); /* A lot of memory */
       10:  252:        trim_leading_whitespace(expansion);
       10:  253:        d_m->expansion = xcalloc(strlen(expansion) + 1, sizeof(char));
       10:  254:        strcpy(d_m->expansion, expansion);
       10:  255:        m->macro = d_m;
       10:  256:        m->type = DEF;
       10:  257:        insert(t, key, m);
       29:  258:    } else if (comment_cnt == 0 && strcmp(macro_type, FUNC_DEF) == 0) {
       10:  259:        strcpy(key, strtok(NULL, "("));
        -:  260:        /* Error check */
       10:  261:        if (*(line_cpy + strlen(macro_type) + strlen(key) + 1) != '(')
    #####:  262:            formatted_uerror("Missing \"(\" in argument function definition!\n", NULL);
        -:  263:
        -:  264:        /* Add as function macro */
       10:  265:        char* arg_list = strtok(NULL, ")");
       10:  266:        trim_whitespace(arg_list);
       10:  267:        char* expansion = strtok(NULL, NEWLINE_CHAR);
       10:  268:        if (!expansion)
    #####:  269:            formatted_uerror("Error in function defintion. Try checking for missing ')'\n", NULL);
       10:  270:        trim_leading_whitespace(expansion);
       10:  271:        init_fun_macro(m, arg_list, expansion);
       10:  272:        insert(t, key, m);
        9:  273:    } else if (comment_cnt == 0 && strcmp(macro_type, INC_DEF) == 0) {
        3:  274:        char* path;
        3:  275:        path = xcalloc(MAX_LINE_LENGTH - 1, sizeof(char));
        -:  276:
        3:  277:        strcpy(path, strtok(NULL, NEWLINE_CHAR));
        3:  278:        trim_leading_whitespace(path);
        3:  279:        include_file(path, t);
        3:  280:        free(path);
        -:  281:        /* Turns out these aren't needed here. TODO refactor */
        3:  282:        free(m);
        3:  283:        free(key);
        -:  284:
        6:  285:    } else if (comment_cnt == 0 && strcmp(macro_type, FILE_DEF) == 0) {
        1:  286:        char* path;
        1:  287:        path = xcalloc(MAX_LINE_LENGTH - 1, sizeof(char));
        1:  288:        strcpy(key, strtok(NULL, " \t"));
        1:  289:        strcpy(path, strtok(NULL, NEWLINE_CHAR));
        1:  290:        trim_leading_whitespace(path);
        1:  291:        init_file_macro(m, path);
        1:  292:        insert(t, key, m);
        1:  293:        free(path);
        5:  294:    } else if (comment_cnt == 0 && strcmp(macro_type, UNDEF_DEF) == 0) {
        1:  295:        strcpy(key, strtok(strtok(NULL, " \t"), NEWLINE_CHAR));
        1:  296:        trim_leading_whitespace(key);
        1:  297:        if (lookup(t, key)) {
        1:  298:            remove_from_table(t, key);
        1:  299:            free(key);
        1:  300:            free(m);
        -:  301:        } else 
    #####:  302:            formatted_uerror("Cannot remove key: %s! It is not defined\n", key);
        4:  303:    } else if (strcmp(macro_type, IF_DEF) == 0) {
        2:  304:        strcpy(key, strtok(strtok(NULL, " \t"), NEWLINE_CHAR));
        2:  305:        trim_leading_whitespace(key);
        2:  306:        if (strcmp(key, BOOL_FALSE) == 0) { /* $IF FALSE */
        2:  307:            ++comment_cnt; 
    #####:  308:        } else if (strcmp(key, BOOL_TRUE) == 0) { /* $IF TRUE */
        -:  309:            ; /* DO NOTHING */
        -:  310:        } else {
    #####:  311:            if (!lookup(t, key)) { /* $IF SOMEUNDEFINEDMACRO */ 
    #####:  312:                ++comment_cnt;
        -:  313:            } 
        -:  314:        }
        2:  315:        free(key);
        2:  316:        free(m);
        2:  317:    } else if (strcmp(macro_type, IFN_DEF) == 0) {
    #####:  318:        strcpy(key, strtok(strtok(NULL, " \t"), NEWLINE_CHAR));
    #####:  319:        trim_leading_whitespace(key);
    #####:  320:        if (strcmp(key, BOOL_FALSE) == 0) { /* $IFN FALSE */
        -:  321:            ; /* DO NOTHING */
    #####:  322:        } else if (strcmp(key, BOOL_TRUE) == 0) { /* $IFN TRUE */
    #####:  323:            comment_cnt++;
        -:  324:        } else {
    #####:  325:            if (lookup(t, key)) { /* $IFN SOMEDEFINEDMACRO */ 
    #####:  326:                ++comment_cnt;
        -:  327:            }
        -:  328:        }
    #####:  329:        free(key);
    #####:  330:        free(m);
        2:  331:    } else if (strcmp(macro_type, ENDIF_DEF) == 0) {
        2:  332:        if (comment_cnt > 0)
        2:  333:            --comment_cnt;
        2:  334:        free(key);
        2:  335:        free(m);
    #####:  336:    } else if (comment_cnt == 0) {
    #####:  337:        formatted_uerror("Unrecoginized token: %s\n", macro_type);
        -:  338:    }
       29:  339:    has_new_keys = 1;
        -:  340:}
        -:  341:
        -:  342:/* 
        -:  343: * Initiates a function macro.
        -:  344: */
       10:  345:void init_fun_macro(macro_t* m, char* arg_list, char* expansion)
       10:  346:{
       10:  347:    func_m* f_m = xmalloc(sizeof(func_m));
       10:  348:    char key_cpy[strlen(arg_list) + 1];
       10:  349:    size_t argc = 0;
       10:  350:    char** argv_tmp = xcalloc(MAX_ARGC, sizeof(char*));
        -:  351:
       10:  352:    m->type = FUN;
       10:  353:    strcpy(key_cpy, arg_list);
       10:  354:    f_m->expansion = xcalloc(strlen(expansion) + 1, sizeof(char));
       10:  355:    strcpy(f_m->expansion, expansion);
       10:  356:    size_t i = 0;
       10:  357:    size_t len = strlen(key_cpy);
       10:  358:    /* find first occurence of RESERVED_MACRO_CHAR */;
        -:  359:    /* TODO: Error handling, missing arg list, or parentheses */
       30:  360:    while (i < len){
        -:  361:        /* Find position of first RESERVED_MACRO_CHAR */
       20:  362:        while(key_cpy[i] != RESERVED_MACRO_CHAR)
    #####:  363:            ++i;
        -:  364:        /* Find position of next ',' or ')' */
        -:  365:        size_t n = i;
       73:  366:        while (key_cpy[n] != ',' &&  key_cpy[n] != '\0')
       53:  367:            n++;
       20:  368:        size_t k;
       20:  369:        argv_tmp[argc] = xcalloc(n - i + 1, sizeof(char));
       73:  370:        for (k = 0; k < n - i; ++k)
       53:  371:            argv_tmp[argc][k] = key_cpy[i + k];
       20:  372:        argc++;
       20:  373:        i += n - i + 1; 
        -:  374:    }
       10:  375:    f_m->argc = argc;
       10:  376:    f_m->argv = xcalloc(argc, sizeof(char*));
       30:  377:    for (i = 0; i < argc; ++i){
       20:  378:        f_m->argv[i] = xcalloc(strlen(argv_tmp[i]) + 1, sizeof(char));
       20:  379:        strcpy(f_m->argv[i], argv_tmp[i]);
        -:  380:    }
      110:  381:    for (i = 0; i < MAX_ARGC; ++i)
      100:  382:        free(argv_tmp[i]);
       10:  383:    free(argv_tmp);
       10:  384:    m->macro = f_m;
       10:  385:}
        -:  386:
        -:  387:/*
        -:  388: * Initiates a file macro.
        -:  389: */
        1:  390:void init_file_macro(macro_t* m, char* path_to_file)
        -:  391:{
        1:  392:    file_m* f_m = xmalloc(sizeof(file_m));
        1:  393:    m->type = FLE;
        1:  394:    f_m->file = fopen(path_to_file, "r");
        1:  395:    if (!f_m->file) 
    #####:  396:        formatted_uerror("Cannot open file %s\n", path_to_file);
        1:  397:    m->macro = f_m;
        -:  398:
        1:  399:}
